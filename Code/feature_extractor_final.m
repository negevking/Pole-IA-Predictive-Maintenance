%DIAGNOSTICFEATURES recreates results in Diagnostic Feature Designer.
%
% Input:
%  inputEnsemble: A file ensemble datastore containing the
%  data as those imported into the app.
%
% Output:
%  featureTable: A table containing all features and condition variables.
%  outputEnsemble: An ensemble datastore containing the computation results.
%
% This function computes spectra:
%  vibration_ps/SpectrumData
%
% This function computes features:
%  vibration_sigstats/ClearanceFactor
%  vibration_sigstats/CrestFactor
%  vibration_sigstats/ImpulseFactor
%  vibration_sigstats/Kurtosis
%  vibration_sigstats/Mean
%  vibration_sigstats/PeakValue
%  vibration_sigstats/RMS
%  vibration_sigstats/SINAD
%  vibration_sigstats/SNR
%  vibration_sigstats/ShapeFactor
%  vibration_sigstats/Skewness
%  vibration_sigstats/Std
%  vibration_sigstats/THD
%  vibration_ps_spec/PeakAmp1
%  vibration_ps_spec/PeakFreq1
%  vibration_ps_spec/BandPower
%
% Organization of the function:
% 1. Compute signals/spectra/features
% 2. Extract computed features into a table
%
% Modify the function to add or remove data processing, feature generation
% or ranking operations.

% Auto-generated by MATLAB on 11-May-2023 08:31:53


hsbearing = fileEnsembleDatastore(...
    fullfile('.', 'Data'), ...
    '.mat');
hsbearing.DataVariables = ["vibration", "tach"]

hsbearing.IndependentVariables = "Date"

hsbearing.SelectedVariables = ["Date", "vibration", "tach"]

hsbearing.ReadFcn = @helperReadData;
hsbearing.WriteToMemberFcn = @helperWriteToHSBearing;
tall(hsbearing)

inputEnsemble = hsbearing;


hsbearing.DataVariables = [hsbearing.DataVariables;"accel"; "AccMean"; "AccStd"; "AccKurtosis"; "AccSkewness"];
reset(hsbearing)

%characteristics - mean, median, max, std, skewness and (kurtosis)
%variables - vibration, speed, acceleration, spectral kurtosis of former
day = 1;
while hasdata(hsbearing)
    data = read(hsbearing);
    statisticData = table;

    tach = data.tach{1};
    [speed, acc] = tach_deriv(tach);
    statisticData.accel = {acc};

    Mean = mean(acc);
    Std = std(acc);
    Kurtosis = kurtosis(acc);
    Skewness = skewness(acc);
    statisticData.AccMean = Mean;
    statisticData.AccStd = Std;
    statisticData.AccKurtosis = Kurtosis;
    statisticData.AccSkewness = Skewness;     

    
    % Write spectral kurtosis values
    writeToLastMemberRead(hsbearing, statisticData);
    day = day+1;

end

hsbearing.SelectedVariables = ['Date'; hsbearing.DataVariables];

acc_table = gather(tall(hsbearing));

acc_features = acc_table(:,5:end);

%inputEnsemble = hsbearing;

%% Features

% Configure input ensemble
inputEnsemble.DataVariables = "vibration";
inputEnsemble.IndependentVariables = "Date";

% Create output ensemble.
outputEnsemble = inputEnsemble;

% Reset the ensemble to read from the beginning of the ensemble.
reset(outputEnsemble);

% Append new signal or feature names to DataVariables.
outputEnsemble.DataVariables = unique([outputEnsemble.DataVariables;"vibration_sigstats";"vibration_ps";"vibration_ps_spec"],'stable');

% Set SelectedVariables to select variables to read from the ensemble.
outputEnsemble.SelectedVariables = "vibration";

% Loop through all ensemble members to read and write data.
while hasdata(outputEnsemble)
    % Read one member.
    member = read(outputEnsemble);

    % Get all input variables.
    vibration = readMemberData(member,"vibration","Col1");
    iv = (0:1:(height(vibration)-1)*1)';
    vibration.Sample = iv;

    % Initialize a table to store results.
    memberResult = table;

    %% SignalFeatures
    try
        % Compute signal features.
        inputSignal = vibration.Col1;
        ClearanceFactor = max(abs(inputSignal))/(mean(sqrt(abs(inputSignal)))^2);
        CrestFactor = peak2rms(inputSignal);
        ImpulseFactor = max(abs(inputSignal))/mean(abs(inputSignal));
        Kurtosis = kurtosis(inputSignal);
        Mean = mean(inputSignal,'omitnan');
        PeakValue = max(abs(inputSignal));
        RMS = rms(inputSignal,'omitnan');
        SINAD = sinad(inputSignal);
        SNR = snr(inputSignal);
        ShapeFactor = rms(inputSignal,'omitnan')/mean(abs(inputSignal),'omitnan');
        Skewness = skewness(inputSignal);
        Std = std(inputSignal,'omitnan');
        THD = thd(inputSignal);

        % Spectral kurtosis

        wc = 128;
        fs = 97656;
        
        [SK, ~] = pkurtosis(inputSignal, fs, wc);
        
        % Compute frequency-domain features from spectral kurtosis
        SKMean = mean(SK);
        SKStd = std(SK);
        SKKurt = kurtosis(SK);

        % Wavelets

        % Perform wavelet analysis
        waveletLevel = 5;  % Adjust the wavelet level as needed
        [C, ~] = wavedec(inputSignal, waveletLevel, 'db4');
        
        % Compute wavelet energy and entropy
        waveletEnergy = sum(C.^2);
        waveletEntropy = entropy(C);

        % Concatenate signal features.
        featureValues = [ClearanceFactor,CrestFactor,ImpulseFactor,Kurtosis,Mean,PeakValue,RMS,SINAD,SNR,ShapeFactor,Skewness,Std,THD,SKMean,SKStd,SKKurt,waveletEnergy,waveletEntropy];
        
        % Package computed features into a table.
        featureNames = ["ClearanceFactor","CrestFactor","ImpulseFactor","Kurtosis","Mean","PeakValue","RMS","SINAD","SNR","ShapeFactor","Skewness","Std","THD","SKMean","SKStd","SKKurt","waveletEnergy","waveletEntropy"];
        
        vibration_sigstats = array2table(featureValues,'VariableNames',featureNames);
        
    catch e
        fprintf(1,'The identifier was:\n%s',e.identifier);
        fprintf(1,'There was an error! The message was:\n%s',e.message);
        % Package computed features into a table.
        featureValues = NaN(1,16);
        featureNames = ["ClearanceFactor","CrestFactor","ImpulseFactor","Kurtosis","Mean","PeakValue","RMS","SINAD","SNR","ShapeFactor","Skewness","Std","THD","SKMean", "SKStd", "SKKurt","waveletEnergy","waveletEntropy"];
        vibration_sigstats = array2table(featureValues,'VariableNames',featureNames);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({vibration_sigstats},'VariableNames',"vibration_sigstats")]; %#ok<AGROW>

    %% PowerSpectrum
    try
        % Get units to use in computed spectrum.
        tuReal = "samples";
        tuTime = "seconds";

        % Compute effective sampling rate.
        tNumeric = time2num(vibration.Sample,tuReal);
        [Fs,irregular] = effectivefs(tNumeric);
        Ts = 1/Fs;

        % Resample non-uniform signals.
        x = vibration.Col1;
        if irregular
            x = resample(x,tNumeric,Fs,'linear');
        end

        % Compute the autoregressive model.
        data = iddata(x,[],Ts,'TimeUnit',tuTime,'OutputName','SpectrumData');
        arOpt = arOptions('Approach','fb','Window','now','EstimateCovariance',false);
        model = ar(data,4,arOpt);

        % Compute the power spectrum.
        [ps,w] = spectrum(model);
        ps = reshape(ps, numel(ps), 1);
        factor = 1/2/pi;
        w = factor*w;

        % Remove frequencies above Nyquist frequency.
        I = w<=(Fs/2+1e4*eps);
        w = w(I);
        ps = ps(I);

        % Configure the computed spectrum.
        ps = table(w, ps, 'VariableNames', ["Frequency", "SpectrumData"]);
        ps.Properties.VariableUnits = ["cycles/sample", ""];
        ps = addprop(ps, {'SampleFrequency'}, {'table'});
        ps.Properties.CustomProperties.SampleFrequency = Fs;
        vibration_ps = ps;
    catch
        vibration_ps = table(NaN, NaN, 'VariableNames', ["Frequency", "SpectrumData"]);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({vibration_ps},'VariableNames',"vibration_ps")]; %#ok<AGROW>

    %% SpectrumFeatures
    try
        % Compute spectral features.
        % Get frequency unit conversion factor.
        factor = 2*pi;
        ps = vibration_ps.SpectrumData;
        w = vibration_ps.Frequency;
        w = factor*w;
        mask_1 = (w>=factor*0.00159154943091895) & (w<=factor*0.5);
        ps = ps(mask_1);
        w = w(mask_1);

        % Compute spectral peaks.
        [peakAmp,peakFreq] = findpeaks(ps,w/factor,'MinPeakHeight',-Inf, ...
            'MinPeakProminence',0,'MinPeakDistance',0.001,'SortStr','descend','NPeaks',1);
        peakAmp = [peakAmp(:); NaN(1-numel(peakAmp),1)];
        peakFreq = [peakFreq(:); NaN(1-numel(peakFreq),1)];

        % Extract individual feature values.
        PeakAmp1 = peakAmp(1);
        PeakFreq1 = peakFreq(1);
        BandPower = trapz(w/factor,ps);

        % Concatenate signal features.
        featureValues = [PeakAmp1,PeakFreq1,BandPower];

        % Package computed features into a table.
        featureNames = ["PeakAmp1","PeakFreq1","BandPower"];
        vibration_ps_spec = array2table(featureValues,'VariableNames',featureNames);
    catch
        % Package computed features into a table.
        featureValues = NaN(1,3);
        featureNames = ["PeakAmp1","PeakFreq1","BandPower"];
        vibration_ps_spec = array2table(featureValues,'VariableNames',featureNames);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({vibration_ps_spec},'VariableNames',"vibration_ps_spec")]; %#ok<AGROW>

    %% Write all the results for the current member to the ensemble.
    writeToLastMemberRead(outputEnsemble,memberResult)
end

% Gather all features into a table.
selectedFeatureNames = ["vibration_sigstats/ClearanceFactor","vibration_sigstats/CrestFactor","vibration_sigstats/ImpulseFactor","vibration_sigstats/Kurtosis","vibration_sigstats/Mean","vibration_sigstats/PeakValue","vibration_sigstats/RMS","vibration_sigstats/SINAD","vibration_sigstats/SNR","vibration_sigstats/ShapeFactor","vibration_sigstats/Skewness","vibration_sigstats/Std","vibration_sigstats/THD", "vibration_sigstats/SKMean", "vibration_sigstats/SKStd","vibration_sigstats/SKKurt","vibration_sigstats/waveletEnergy","vibration_sigstats/waveletEntropy","vibration_ps_spec/PeakAmp1","vibration_ps_spec/PeakFreq1","vibration_ps_spec/BandPower"];
featureTable = readFeatureTable(outputEnsemble,'Features',selectedFeatureNames);

featureTable = [featureTable acc_features];

writetable(featureTable, 'featureSets/brute_features.txt')

% Set SelectedVariables to select variables to read from the ensemble.
outputEnsemble.SelectedVariables = unique([outputEnsemble.DataVariables;outputEnsemble.ConditionVariables;outputEnsemble.IndependentVariables],'stable');
